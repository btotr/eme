<html>
    <head>
        <title>media source</title>
        <style type="text/css">
            body, html {
                padding:0; margin:0;
                min-width:1280px;
            }
        </style>
    </head>
    <body>
    <video autoplay></video>
    <script>

        function MediaInfo() {
            this.offset   = 0;
            this.buffer   = 0;
            this.chunks   = 10;
            this.chunkSize = function(){
                return Math.floor(this.sizeInBytes/this.chunks);
            };
            this.queue = [];
        }

        var videoInfo = new MediaInfo();
        videoInfo.mediaURL = "video";
        videoInfo.mime     = "video/mp4; codecs=\"avc1.64001F\"";
        // ffprobe test.mp4  -show_format | grep size;
        videoInfo.sizeInBytes = 7181049;
        videoInfo.chunks   = 20;

        var audioInfo = new MediaInfo();
        audioInfo.mediaURL = "audio";
        audioInfo.mime     = "audio/mp4; codecs=\"mp4a.40.2\"";
        audioInfo.sizeInBytes = 801059;

        var onSourceOpen = function() {
            if (ms.sourceBuffers.length) {
                return;
            }
            // attach the source buffers
            videoInfo.buffer = ms.addSourceBuffer(videoInfo.mime);
            audioInfo.buffer = ms.addSourceBuffer(audioInfo.mime);
            // load the first chunks
            loadChunk.call(videoInfo);
            loadChunk.call(audioInfo);
        };

        function nextChunk(){
            if (this.offset === this.chunks - 1) {
                console.log("all chunks downloaded from: " + this.mediaURL);
                return;
            }
            this.offset++;
            loadChunk.call(this);
        }

        function loadChunk(){
            var xhr = new XMLHttpRequest();
            xhr.open("GET", this.mediaURL);
            xhr.responseType = "arraybuffer";
            var chunkSize = this.chunkSize();
            var startByte = parseInt(chunkSize * this.offset);
            var range = startByte + "-" + (startByte + chunkSize - 1);
            console.info("loading next chunk: ", range, this.offset);
            xhr.setRequestHeader("Range", "bytes=" + range);

            var self = this;
            xhr.addEventListener("load", function(e) {
                var buf = new Uint8Array(e.target.response);

                // only update if we are finishing updating
                if (self.buffer.updating || self.queue.length === 0) {
                    self.queue.push(buf);
                    if (self.buffer.updating) {
                        return;
                    }
                }

                var append = function(buffer) {
                    // cloudtv doesn't support appendBuffer use append instead
                    if (!self.buffer.appendBuffer) {
                        self.buffer.append(buffer);
                        return;
                    }
                    self.buffer.appendBuffer(buffer);
                };

                // append buffer to source buffer
                append(self.queue.shift());

                var testUpdate = function(timeEvent){
                    var dur = video.duration;
                    if (isNaN(dur) || dur === Infinity) {
                        dur = 33; //static if no video durartion
                    }
                    var chunkDuration = dur/self.chunks;
                    // 40% fudge factor
                    var threshold = self.offset * chunkDuration * 0.6;
                    if (timeEvent.target.currentTime >= threshold) {
                        video.removeEventListener("timeupdate", testUpdate, false);
                        nextChunk.call(self);
                    }
                };
                video.addEventListener("timeupdate", testUpdate, false);
            });
            xhr.send();
        }

        // attach to video element
        var video = document.getElementsByTagName("video")[0];
        
        // MSE
        if (window.WebKitMediaSource !== undefined) {
            window.MediaSource = window.WebKitMediaSource;
        }
        var ms = new MediaSource();
        ms.addEventListener("sourceopen", onSourceOpen);
        ms.addEventListener("webkitsourceopen", onSourceOpen);
        
        video.src =  window.URL.createObjectURL(ms);
        
        // EME
       function updateCDM(e){
          // license request
          var xhr = new XMLHttpRequest();
          var keyid = String.fromCharCode.apply(null, new Uint8Array(e.message));
          xhr.responseType = "arraybuffer";
          xhr.open("GET", "https://192.168.62.11:8584?keyid="+keyid);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4 && xhr.status == 200) {
               var updateMessage = xhr.response
               e.target.update(updateMessage).then(function() {
                 console.log("succesfull cdm update");
               },function(e){console.log(e)});
            }
         }
          xhr.send()
       }
       
       var beenThereDoneThat = false;
       video.addEventListener("encrypted", function(ev) {
         // only do it for the first media buffer
          if (beenThereDoneThat) return
         beenThereDoneThat = true
         console.log("video is encrypted");    
         navigator.requestMediaKeySystemAccess("org.w3.clearkey", [
            {
               initDataTypes: ["cenc"],
               videoCapabilities: [{contentType: videoInfo.mime}],
               audioCapabilities: [{contentType: audioInfo.mime}]
            } 
         ]).then(function(keySystemAccess) {
             return keySystemAccess.createMediaKeys();
         }).then(function(mediaKeys) {
             return video.setMediaKeys(mediaKeys);
         }).then(function() {
             var session = video.mediaKeys.createSession();
             session.addEventListener("message", function(e){ updateCDM(e)});
             return session.generateRequest(ev.initDataType, ev.initData);
           }).then(function() {
             console.log("generated cdm request");
           });
       });

    </script>
    </body>
</html>